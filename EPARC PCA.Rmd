---
title: "EPARC PCA"
author: "Lucy Wang"
date: "12/24/2020"
output: 
  pdf_document:
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(ggplot2)
library(knitr)
library(reshape2)
library(xlsx)
library(pheatmap)

knitr::opts_chunk$set(fig.width = 8, message=F, 
                      echo=T, tidy.opts=list(width.cutoff=60), 
                      tidy=T)


setwd("/Users/lucywang/Google Drive/Doyle Lab/Final EPARC Epoxide")
```

# Preprocessing 

## Reading in Data 

Read in df, Remove ee (as ΔΔG^‡^ are calculated from them) and ArCl, a character vector containing ligand names. For demonstration purposes, we are importing NiArCl dataset. 

```{r read_in}
df<-na.omit(read.csv("/Users/lucywang/Google Drive/Doyle Lab/Final EPARC Epoxide/[Export] Final Optimized PARC Epoxide NiArCl.csv"))

# Set aside ArCl names as a vector
ar<-df$ArCl

# Define coordination, a handy character vector for labeling graphs
coordination<-"LNiArCl"

# Delete some redundant variables 
df<-df[, -c(grep("ee",colnames(df)), 
           grep("ArCl",colnames(df)))]

#L.Class as factor variable
df$L.Class<-as.factor(df$L.Class)

# ID as character variable
df$ID<-as.character(df$ID)

# Change torsions to positive values 
df$Torsion<-abs(df$Torsion)
  
# Check structure 
str(df)

#Number of observations
m<-nrow(df)

# change output to ddG for simplicity 
colnames(df)[2]<-"ddG"
```

#  Feature Scaling 

Before proceeding with PCA, data will be scaled. The values of each parameter will be converted into a Z score. ddG will be removed since it is not a feature. 

```{r scale}
# Remove non-numeric/integer parameters 

df.num<-df[,-c(
  grep("ID", colnames(df)), 
  grep("ddG", colnames(df)), 
  grep("L.Class", colnames(df))
)]


# Center and Scale input matrix
df.sc0<-scale(df.num)
  str(df.sc0)

# Save scaling attributes (i.e. mean and sd of each parameter)
sc.att.cl<-list(scale=attr(df.sc0, "scaled:scale"), 
                center=attr(df.sc0, "scaled:center"))

#Add in ID as rownames
rownames(df.sc0)<-ar

#Save as data.frame
df.sc<-as.data.frame(df.sc0)

```

# Heatmap
As a quick detour, let's take a look at a heatmap of the dataset. 

```{r heatmap}
pheatmap(df.sc0, scale="column", 
         color=hcl.colors(100, palette="prgn"), main=coordination
)
```


# Principal Component Analysis 

Use `prcomp()` to conduct PCA on the input matrix. 

```{r pca}
pca.cl<-prcomp(df.sc, 
               scale=T)
```

Find eigenvalues and construct Scree plot. 
```{r eigenvalue_var}

# check for variation accounted for by each PC (this is equal to the eigenvalue)
pca.cl.var<-pca.cl$sdev^2

  # calculate percentage 
  pca.cl.var.per<-round(pca.cl.var/sum(pca.cl.var)*100, 
                     1)
# Display 
pca.cl.var.per
```


```{r scree}
  # df wrangling
  df.pca.scree<-data.frame(
    PC=seq(1:length(pca.cl.var.per)), 
    "Percent Var Captured"=pca.cl.var.per, 
    "Eigenvalue"=round(pca.cl.var, 2)
  )
  
    levels(df.pca.scree$PC)<-df.pca.scree$PC
    
  
  # scree plot 
  ggplot(df.pca.scree, 
         aes(x=PC, 
             y=Percent.Var.Captured)) + 
    geom_bar(stat="identity") + 
    geom_text(aes(label=Percent.Var.Captured), 
              vjust=-0.5) + 
    ggtitle(paste0(c(
      "Scree Plot,", coordination
    ), collapse=" ")) + 
    scale_x_continuous(breaks=1:nrow(df.pca.scree)) + 
    ylab("Percent Variation Captured")
```

PC Plots; (here, of the first two principal components)

```{r PC_plot}
# ggplot2
  # Make df for ggplot()
  pca.df<-data.frame(
    'ID'=df$ID, 
    "PCA1"=pca.cl$x[,1], 
    'PCA2'=pca.cl$x[,2], 
    "L.Class"=df$L.Class
  )
  
  # plot 
  pca12<-ggplot(pca.df, 
         aes(x=PCA1, 
             y=PCA2, 
             label=ID, 
             color=L.Class))+
    geom_point()+
    xlab(paste(
      "PC1-", pca.cl.var.per[1], "%", sep=""
    )) + 
    ylab(paste(
      "PC2-", pca.cl.var.per[2], "%", sep=""
    )
    ) + 
    ggtitle(paste(c(
      "Principal Component Analysis,", coordination), 
      collapse=" ")) 
  
  # Display plot 
  pca12
  
  # Can also add ID labels 
  pca12geom<-pca12+geom_text(vjust=1, hjust=1)
```

Calculate feature loadings with `load.scores.f()`

* `i`: the $i^{th}$ principal component 
* `k`: the top $k$ features with the largest magnitude 

```{r load_scores_f}
load.scores.f<-function(i, k=10,
                        pca_output){
  # Check magnitude by taking absolute value 
  load.scores<-abs(pca_output$rotation[,i]
                   )
  # sort loading scores in decreasing magnitude 
  load.scores.ranked<-round(sort(load.scores, 
                           decreasing=T), 
                           3)
  
  # Find first k features
  top.k.features<-names(load.scores.ranked)[1:k]
  
  # check their loading scores (+/-)
  
    return( list('Loading Score Magnitudes, Ranked'=load.scores.ranked,
                 "Top Features and Loading Scores"=pca_output$rotation[top.k.features, i])
    )
}
```


```{r pca_load_scores}
# Check loading scores for PC1 and PC2
load.pc1<-data.frame('load.scores'=load.scores.f(i=1, 
                        k=ncol(df.sc0), 
                        pca.cl)[[2]])
load.pc2<-data.frame('load.scores'=load.scores.f(i=2, 
                        k=ncol(df.sc0), 
                        pca.cl)[[2]])

kable(load.pc1)
kable(load.pc2)
```

Plot the loading scores of PC1 and PC2. 

```{r loading_plot}
# create data frame for ggplot 
df.load.gg0<-data.frame(
  "Feature"=c(
    rownames(load.pc1),
    rownames(load.pc2)
  ), 
  "Loading Score"=c(
    load.pc1[,1], 
    load.pc2[,1]
  ), 
  "PC"=rep(c(1,2), 
           each=nrow(load.pc1))
)
  
  # reshape 
  df.load.gg<-dcast(df.load.gg0,
                    Feature~PC, 
                    value.var = "Loading.Score")
    # rename columns 
    colnames(df.load.gg)[2:3]<-c(
      "PC1", "PC2"
    )
    
    #Plot 
    ggplot(df.load.gg, 
           aes(x=PC1,
      y=PC2, 
      color=Feature)) + 
    geom_point(alpha=0.6) + 
      xlim(-0.4, 0.4) + 
      ggtitle(paste(
        c("Loading Scores of PC1 and PC2,", 
          coordination), collapse=" "
      )) 
  
```
